---
name: <%* 
  const termName = await tp.system.prompt("è¯·è¾“å…¥æœ¯è¯­åç§°ï¼ˆå¿…å¡«ï¼‰", "");
  if (!termName || !termName.trim()) {
    const currentFile = tp.file.find_tfile(tp.file.path(true));
    if (currentFile) { await app.vault.trash(currentFile, true); }
    new Notice("æœªè¾“å…¥æœ¯è¯­åç§°ï¼Œå·²å–æ¶ˆåˆ›å»ºå¹¶åˆ é™¤è‰ç¨¿ã€‚");
    throw new Error("æœªè¾“å…¥æœ¯è¯­åç§°ï¼Œå·²å–æ¶ˆã€‚");
  }
  
  const trimmedName = termName.trim();
  
  // é‡å‘½åæ–‡ä»¶
  if (trimmedName !== tp.file.title) {
    try {
      await tp.file.rename(trimmedName);
    } catch (error) {
      const currentFile = tp.file.find_tfile(tp.file.path(true));
      if (currentFile) { await app.vault.trash(currentFile, true); }
      new Notice("é‡å‘½åå¤±è´¥ï¼Œå·²åˆ é™¤è‰ç¨¿ï¼š" + error.message);
      throw error;
    }
  }
  
  tR += trimmedName;
%>
<%* 
  const aliasesInput = await tp.system.prompt("è¯·è¾“å…¥æœ¯è¯­åˆ«åï¼Œå¤šä¸ªåˆ«åç”¨é€—å·åˆ†éš”ï¼Œç•™ç©ºåˆ™è·³è¿‡", "");
  if (aliasesInput && aliasesInput.trim()) {
    const aliases = aliasesInput.split(/[,ï¼Œ]/).map(a => a.trim()).filter(a => a);
    if (aliases.length > 0) {
      tR += "aliases:\n";
      aliases.forEach(alias => {
        tR += `  - ${alias}\n`;
      });
    }
  }
  tR += "tags:\n  - concept\n";
%>
---

## Description

> [!seealso]+ Source
> 
> ğŸ’¡ **æœ¬æ¦‚å¿µæ˜¯æ‰‹åŠ¨æ·»åŠ çš„**

<!-- markdownlint-disable-next-line MD028 -->
> [!note] Definition
> 
<%* 
  const definition = await tp.system.prompt("è¯·è¾“å…¥æœ¯è¯­çš„å®šä¹‰è¯´æ˜ï¼Œå•è¡Œè¾“å…¥ï¼Œå¦‚éœ€å¤šè¡Œè¯·åœ¨ç”Ÿæˆåæ‰‹åŠ¨ç¼–è¾‘", "");
  if (definition && definition.trim()) {
    tR += `> ${definition}`;
  } else {
    tR += "> å¾…è¡¥å……";
  }
%>

## ç›¸å…³è®ºæ–‡

![[æ¦‚å¿µæ£€ç´¢è®ºæ–‡.base]]

## ç›¸å…³æƒ³æ³•

```dataviewjs

let folderChoicePaths = ["00 - æ¯æ—¥æ—¥è®°/DailyNote", "Inputs", "Outputs", "Projects"];
const specificTag = "#æƒ³æ³•"; // æŒ‡å®šè¦æ£€æŸ¥çš„æ ‡ç­¾ï¼Œå¯ä»¥æ›´æ”¹

const files = app.vault.getMarkdownFiles().filter(file => folderChoicePaths.some(path => file.path.includes(path)) );

let names = dv.current().aliases ? dv.current().aliases : [];
names.push(dv.current().name);
names.push(dv.current().ch);

let arr = files.map(async(file) => {
    const content = await app.vault.cachedRead(file);
    // ç¡®ä¿æ–‡ä»¶å†…å®¹åŒ…å«ç‰¹å®šæ ‡ç­¾
    if (content.includes(specificTag)) {
        let lines = content.split("\n").filter(line => names.some(name => line.includes(name)));
        return ["[[" + file.name.split(".")[0] + "]]", lines];
    }
    return null; // å¦‚æœä¸åŒ…å«æ ‡ç­¾ï¼Œè¿”å› null
});

Promise.all(arr).then(values => {
    // è¿‡æ»¤æ‰ null ç»“æœ
    const filteredValues = values.filter(value => value != null);

    const beautify = filteredValues.map(value => {
        const temp = value[1].map(line => line); // ç¾åŒ–å¤„ç†
        return [value[0], temp];
    });

    const exists = beautify.filter(value => value[1][0] && value[0] != "[[æœªå‘½å 10]]")
        .sort((a, b) => a[0].localeCompare(b[0])); // æ’åºå¤„ç†ä¿®æ­£ä¸º localeCompare

    dv.table(["æ—¥æœŸ", "åŠ¨æ€"], exists);
});

```
